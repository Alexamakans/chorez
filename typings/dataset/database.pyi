"""
This type stub file was generated by pyright.
"""

log = ...
class Database:
    """A database object represents a SQL database with multiple tables."""
    def __init__(self, url, schema=..., engine_kwargs=..., ensure_schema=..., row_type=..., sqlite_wal_mode=..., on_connect_statements=...) -> None:
        """Configure and connect to the database."""
        ...
    
    @property
    def executable(self):
        """Connection against which statements will be executed."""
        ...
    
    @property
    def op(self): # -> Operations:
        """Get an alembic operations context."""
        ...
    
    @property
    def inspect(self): # -> None:
        """Get a SQLAlchemy inspector."""
        ...
    
    def has_table(self, name):
        ...
    
    @property
    def metadata(self): # -> MetaData:
        """Return a SQLAlchemy schema cache object."""
        ...
    
    @property
    def in_transaction(self): # -> bool:
        """Check if this database is in a transactional context."""
        ...
    
    def begin(self): # -> None:
        """Enter a transaction explicitly.

        No data will be written until the transaction has been committed.
        """
        ...
    
    def commit(self): # -> None:
        """Commit the current transaction.

        Make all statements executed since the transaction was begun permanent.
        """
        ...
    
    def rollback(self): # -> None:
        """Roll back the current transaction.

        Discard all statements executed since the transaction was begun.
        """
        ...
    
    def __enter__(self): # -> Self:
        """Start a transaction."""
        ...
    
    def __exit__(self, error_type, error_value, traceback): # -> None:
        """End a transaction by committing or rolling back."""
        ...
    
    def close(self): # -> None:
        """Close database connections. Makes this object unusable."""
        ...
    
    @property
    def tables(self):
        """Get a listing of all tables that exist in the database."""
        ...
    
    @property
    def views(self):
        """Get a listing of all views that exist in the database."""
        ...
    
    def __contains__(self, table_name): # -> bool:
        """Check if the given table name exists in the database."""
        ...
    
    def create_table(self, table_name, primary_id=..., primary_type=..., primary_increment=...): # -> None:
        """Create a new table.

        Either loads a table or creates it if it doesn't exist yet. You can
        define the name and type of the primary key field, if a new table is to
        be created. The default is to create an auto-incrementing integer,
        ``id``. You can also set the primary key to be a string or big integer.
        The caller will be responsible for the uniqueness of ``primary_id`` if
        it is defined as a text type. You can disable auto-increment behaviour
        for numeric primary keys by setting `primary_increment` to `False`.

        Returns a :py:class:`Table <dataset.Table>` instance.
        ::

            table = db.create_table('population')

            # custom id and type
            table2 = db.create_table('population2', 'age')
            table3 = db.create_table('population3',
                                     primary_id='city',
                                     primary_type=db.types.text)
            # custom length of String
            table4 = db.create_table('population4',
                                     primary_id='city',
                                     primary_type=db.types.string(25))
            # no primary key
            table5 = db.create_table('population5',
                                     primary_id=False)
        """
        ...
    
    def load_table(self, table_name): # -> None:
        """Load a table.

        This will fail if the tables does not already exist in the database. If
        the table exists, its columns will be reflected and are available on
        the :py:class:`Table <dataset.Table>` object.

        Returns a :py:class:`Table <dataset.Table>` instance.
        ::

            table = db.load_table('population')
        """
        ...
    
    def get_table(self, table_name, primary_id=..., primary_type=..., primary_increment=...): # -> None:
        """Load or create a table.

        This is now the same as ``create_table``.
        ::

            table = db.get_table('population')
            # you can also use the short-hand syntax:
            table = db['population']
        """
        ...
    
    def __getitem__(self, table_name): # -> None:
        """Get a given table."""
        ...
    
    def query(self, query, *args, **kwargs): # -> ResultIter:
        """Run a statement on the database directly.

        Allows for the execution of arbitrary read/write queries. A query can
        either be a plain text string, or a `SQLAlchemy expression
        <http://docs.sqlalchemy.org/en/latest/core/tutorial.html#selecting>`_.
        If a plain string is passed in, it will be converted to an expression
        automatically.

        Further positional and keyword arguments will be used for parameter
        binding. To include a positional argument in your query, use question
        marks in the query (i.e. ``SELECT * FROM tbl WHERE a = ?``). For
        keyword arguments, use a bind parameter (i.e. ``SELECT * FROM tbl
        WHERE a = :foo``).
        ::

            statement = 'SELECT user, COUNT(*) c FROM photos GROUP BY user'
            for row in db.query(statement):
                print(row['user'], row['c'])

        The returned iterator will yield each result sequentially.
        """
        ...
    
    def __repr__(self): # -> LiteralString:
        """Text representation contains the URL."""
        ...
    


